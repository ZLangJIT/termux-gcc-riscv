patch file
diff --git a/nixos/modules/config/system-path.nix b/nixos/modules/config/system-path.nix
index 562100ad6..d9d93d508 100644
--- a/nixos/modules/config/system-path.nix
+++ b/nixos/modules/config/system-path.nix
@@ -8,43 +8,45 @@ with lib;
 let
 
   requiredPackages = map (pkg: setPrio ((pkg.meta.priority or 5) + 3) pkg)
-    [ pkgs.acl
-      pkgs.attr
-      pkgs.bashInteractive # bash with ncurses support
-      pkgs.bzip2
-      pkgs.coreutils-full
-      pkgs.cpio
-      pkgs.curl
-      pkgs.diffutils
-      pkgs.findutils
-      pkgs.gawk
-      pkgs.stdenv.cc.libc
-      pkgs.getent
-      pkgs.getconf
-      pkgs.gnugrep
-      pkgs.gnupatch
-      pkgs.gnused
-      pkgs.gnutar
-      pkgs.gzip
-      pkgs.xz
-      pkgs.less
-      pkgs.libcap
-      pkgs.ncurses
-      pkgs.netcat
-      config.programs.ssh.package
-      pkgs.mkpasswd
-      pkgs.procps
-      pkgs.su
-      pkgs.time
-      pkgs.util-linux
-      pkgs.which
-      pkgs.zstd
+    [
+#      pkgs.acl
+#      pkgs.attr
+#      pkgs.bashInteractive # bash with ncurses support
+#      pkgs.bzip2
+#      pkgs.coreutils-full
+#      pkgs.cpio
+#      pkgs.curl
+#      pkgs.diffutils
+#      pkgs.findutils
+#      pkgs.gawk
+#      pkgs.stdenv.cc.libc
+#      pkgs.getent
+#      pkgs.getconf
+#      pkgs.gnugrep
+#      pkgs.gnupatch
+#      pkgs.gnused
+#      pkgs.gnutar
+#      pkgs.gzip
+#      pkgs.xz
+#      pkgs.less
+#      pkgs.libcap
+#      pkgs.ncurses
+#      pkgs.netcat
+#      config.programs.ssh.package
+#      pkgs.mkpasswd
+#      pkgs.procps
+#      pkgs.su
+#      pkgs.time
+#      pkgs.util-linux
+#      pkgs.which
+#      pkgs.zstd
     ];
 
   defaultPackageNames =
-    [ "perl"
-      "rsync"
-      "strace"
+    [
+#      "perl"
+#      "rsync"
+#      "strace"
     ];
   defaultPackages =
     map
diff --git a/nixos/modules/installer/cd-dvd/installation-cd-base.nix b/nixos/modules/installer/cd-dvd/installation-cd-base.nix
index 3f92b779d..3c72ecdfd 100644
--- a/nixos/modules/installer/cd-dvd/installation-cd-base.nix
+++ b/nixos/modules/installer/cd-dvd/installation-cd-base.nix
@@ -46,5 +46,5 @@ with lib;
     done
   '';
 
-  system.stateVersion = lib.mkDefault lib.trivial.release;
+  config.system.stateVersion = lib.mkDefault lib.trivial.release;
 }
diff --git a/nixos/modules/installer/cd-dvd/iso-image.nix b/nixos/modules/installer/cd-dvd/iso-image.nix
index e516d8ea6..32f7d2ec0 100644
--- a/nixos/modules/installer/cd-dvd/iso-image.nix
+++ b/nixos/modules/installer/cd-dvd/iso-image.nix
@@ -1,18 +1,14 @@
 # This module creates a bootable ISO image containing the given NixOS
 # configuration.  The derivation for the ISO image will be placed in
 # config.system.build.isoImage.
-
 { config, lib, pkgs, ... }:
-
-with lib;
-
 let
   /**
    * Given a list of `options`, concats the result of mapping each options
    * to a menuentry for use in grub.
    *
    *  * defaults: {name, image, params, initrd}
-   *  * options: [ option...Â ]
+   *  * options: [ option... ]
    *  * option: {name, params, class}
    */
   menuBuilderGrub2 =
@@ -22,8 +18,8 @@ let
       (option: ''
         menuentry '${defaults.name} ${
         # Name appended to menuentry defaults to params if no specific name given.
-        option.name or (optionalString (option ? params) "(${option.params})")
-        }' ${optionalString (option ? class) " --class ${option.class}"} {
+        option.name or (lib.optionalString (option ? params) "(${option.params})")
+        }' ${lib.optionalString (option ? class) " --class ${option.class}"} {
           # Fallback to UEFI console for boot, efifb sometimes has difficulties.
           terminal_output console
 
@@ -56,7 +52,7 @@ let
   let
     finalCfg = {
       name = "${config.isoImage.prependToMenuLabel}${config.system.nixos.distroName} ${config.system.nixos.label}${config.isoImage.appendToMenuLabel}";
-      params = "init=${config.system.build.toplevel}/init ${additional} ${toString config.boot.kernelParams}";
+      params = "console=ttyS0 init=${config.system.build.toplevel}/init ${additional} ${toString config.boot.kernelParams}";
       image = "/boot/${config.system.boot.loader.kernelFile}";
       initrd = "/boot/initrd";
     };
@@ -114,28 +110,28 @@ let
     LABEL boot
     MENU LABEL ${config.isoImage.prependToMenuLabel}${config.system.nixos.distroName} ${config.system.nixos.label}${config.isoImage.appendToMenuLabel}
     LINUX /boot/${config.system.boot.loader.kernelFile}
-    APPEND init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams}
+    APPEND console=ttyS0 init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams}
     INITRD /boot/${config.system.boot.loader.initrdFile}
 
     # A variant to boot with 'nomodeset'
     LABEL boot-nomodeset
     MENU LABEL ${config.isoImage.prependToMenuLabel}${config.system.nixos.distroName} ${config.system.nixos.label}${config.isoImage.appendToMenuLabel} (nomodeset)
     LINUX /boot/${config.system.boot.loader.kernelFile}
-    APPEND init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams} nomodeset
+    APPEND console=ttyS0 init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams} nomodeset
     INITRD /boot/${config.system.boot.loader.initrdFile}
 
     # A variant to boot with 'copytoram'
     LABEL boot-copytoram
     MENU LABEL ${config.isoImage.prependToMenuLabel}${config.system.nixos.distroName} ${config.system.nixos.label}${config.isoImage.appendToMenuLabel} (copytoram)
     LINUX /boot/${config.system.boot.loader.kernelFile}
-    APPEND init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams} copytoram
+    APPEND console=ttyS0 init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams} copytoram
     INITRD /boot/${config.system.boot.loader.initrdFile}
 
     # A variant to boot with verbose logging to the console
     LABEL boot-debug
     MENU LABEL ${config.isoImage.prependToMenuLabel}${config.system.nixos.distroName} ${config.system.nixos.label}${config.isoImage.appendToMenuLabel} (debug)
     LINUX /boot/${config.system.boot.loader.kernelFile}
-    APPEND init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams} loglevel=7
+    APPEND console=ttyS0 init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams} loglevel=7
     INITRD /boot/${config.system.boot.loader.initrdFile}
 
     # A variant to boot with a serial console enabled
@@ -153,8 +149,8 @@ let
     APPEND ${toString config.boot.loader.grub.memtest86.params}
   '';
 
-  isolinuxCfg = concatStringsSep "\n"
-    ([ baseIsolinuxCfg ] ++ optional config.boot.loader.grub.memtest86.enable isolinuxMemtest86Entry);
+  isolinuxCfg = lib.concatStringsSep "\n"
+    ([ baseIsolinuxCfg ] ++ lib.optional config.boot.loader.grub.memtest86.enable isolinuxMemtest86Entry);
 
   refindBinary = if targetArch == "x64" || targetArch == "aa64" then "refind_${targetArch}.efi" else null;
 
@@ -163,7 +159,7 @@ let
     if refindBinary != null then
       ''
       # Adds rEFInd to the ISO.
-      cp -v ${pkgs.refind}/share/refind/${refindBinary} $out/EFI/boot/
+      cp -v ${pkgs.refind}/share/refind/${refindBinary} $out/EFI/BOOT/
       ''
     else
       "# No refind for ${targetArch}"
@@ -182,7 +178,7 @@ let
     insmod gfxterm
     insmod png
     set gfxpayload=keep
-    set gfxmode=${concatStringsSep "," [
+    set gfxmode=${lib.concatStringsSep "," [
       # GRUB will use the first valid mode listed here.
       # `auto` will sometimes choose the smallest valid mode it detects.
       # So instead we'll list a lot of possibly valid modes :/
@@ -214,11 +210,11 @@ let
     ${ # When there is a theme configured, use it, otherwise use the background image.
     if config.isoImage.grubTheme != null then ''
       # Sets theme.
-      set theme=(\$root)/EFI/boot/grub-theme/theme.txt
+      set theme=(\$root)/EFI/BOOT/grub-theme/theme.txt
       # Load theme fonts
-      $(find ${config.isoImage.grubTheme} -iname '*.pf2' -printf "loadfont (\$root)/EFI/boot/grub-theme/%P\n")
+      $(find ${config.isoImage.grubTheme} -iname '*.pf2' -printf "loadfont (\$root)/EFI/BOOT/grub-theme/%P\n")
     '' else ''
-      if background_image (\$root)/EFI/boot/efi-background.png; then
+      if background_image (\$root)/EFI/BOOT/efi-background.png; then
         # Black background means transparent background when there
         # is a background image set... This seems undocumented :(
         set color_normal=black/black
@@ -239,7 +235,7 @@ let
     nativeBuildInputs = [ pkgs.buildPackages.grub2_efi ];
     strictDeps = true;
   } ''
-    mkdir -p $out/EFI/boot/
+    mkdir -p $out/EFI/BOOT
 
     # Add a marker so GRUB can find the filesystem.
     touch $out/EFI/nixos-installer-image
@@ -313,15 +309,15 @@ let
     # probe for devices, even with --skip-fs-probe.
     grub-mkimage \
       --directory=${grubPkgs.grub2_efi}/lib/grub/${grubPkgs.grub2_efi.grubTarget} \
-      -o $out/EFI/boot/boot${targetArch}.efi \
-      -p /EFI/boot \
+      -o $out/EFI/BOOT/BOOT${lib.toUpper targetArch}.EFI \
+      -p /EFI/BOOT \
       -O ${grubPkgs.grub2_efi.grubTarget} \
       ''${MODULES[@]}
-    cp ${grubPkgs.grub2_efi}/share/grub/unicode.pf2 $out/EFI/boot/
+    cp ${grubPkgs.grub2_efi}/share/grub/unicode.pf2 $out/EFI/BOOT/
 
-    cat <<EOF > $out/EFI/boot/grub.cfg
+    cat <<EOF > $out/EFI/BOOT/grub.cfg
 
-    set textmode=${boolToString (config.isoImage.forceTextMode)}
+    set textmode=${lib.boolToString (config.isoImage.forceTextMode)}
     set timeout=${toString grubEfiTimeout}
 
     clear
@@ -335,12 +331,12 @@ let
     ${grubMenuCfg}
 
     hiddenentry 'Text mode' --hotkey 't' {
-      loadfont (\$root)/EFI/boot/unicode.pf2
+      loadfont (\$root)/EFI/BOOT/unicode.pf2
       set textmode=true
       terminal_output console
     }
     hiddenentry 'GUI mode' --hotkey 'g' {
-      $(find ${config.isoImage.grubTheme} -iname '*.pf2' -printf "loadfont (\$root)/EFI/boot/grub-theme/%P\n")
+      $(find ${config.isoImage.grubTheme} -iname '*.pf2' -printf "loadfont (\$root)/EFI/BOOT/grub-theme/%P\n")
       set textmode=false
       terminal_output gfxterm
     }
@@ -415,7 +411,7 @@ let
         # Force root to be the FAT partition
         # Otherwise it breaks rEFInd's boot
         search --set=root --no-floppy --fs-uuid 1234-5678
-        chainloader (\$root)/EFI/boot/${refindBinary}
+        chainloader (\$root)/EFI/BOOT/${refindBinary}
       }
     fi
     ''}
@@ -431,7 +427,7 @@ let
     }
     EOF
 
-    grub-script-check $out/EFI/boot/grub.cfg
+    grub-script-check $out/EFI/BOOT/grub.cfg
 
     ${refind}
   '';
@@ -444,8 +440,8 @@ let
     #   dates (cp -p, touch, mcopy -m, faketime for label), IDs (mkfs.vfat -i)
     ''
       mkdir ./contents && cd ./contents
-      mkdir -p ./EFI/boot
-      cp -rp "${efiDir}"/EFI/boot/{grub.cfg,*.efi} ./EFI/boot
+      mkdir -p ./EFI/BOOT
+      cp -rp "${efiDir}"/EFI/BOOT/{grub.cfg,*.EFI,*.efi} ./EFI/BOOT
 
       # Rewrite dates for everything in the FS
       find . -exec touch --date=2000-01-01 {} +
@@ -480,7 +476,7 @@ in
 {
   options = {
 
-    isoImage.isoName = mkOption {
+    isoImage.isoName = lib.mkOption {
       default = "${config.isoImage.isoBaseName}.iso";
       type = lib.types.str;
       description = ''
@@ -488,7 +484,7 @@ in
       '';
     };
 
-    isoImage.isoBaseName = mkOption {
+    isoImage.isoBaseName = lib.mkOption {
       default = config.system.nixos.distroId;
       type = lib.types.str;
       description = ''
@@ -496,7 +492,7 @@ in
       '';
     };
 
-    isoImage.compressImage = mkOption {
+    isoImage.compressImage = lib.mkOption {
       default = false;
       type = lib.types.bool;
       description = ''
@@ -505,7 +501,7 @@ in
       '';
     };
 
-    isoImage.squashfsCompression = mkOption {
+    isoImage.squashfsCompression = lib.mkOption {
       default = "zstd -Xcompression-level 19";
       type = lib.types.nullOr lib.types.str;
       description = ''
@@ -515,7 +511,7 @@ in
       example = "zstd -Xcompression-level 6";
     };
 
-    isoImage.edition = mkOption {
+    isoImage.edition = lib.mkOption {
       default = "";
       type = lib.types.str;
       description = ''
@@ -524,9 +520,9 @@ in
       '';
     };
 
-    isoImage.volumeID = mkOption {
+    isoImage.volumeID = lib.mkOption {
       # nixos-$EDITION-$RELEASE-$ARCH
-      default = "nixos${optionalString (config.isoImage.edition != "") "-${config.isoImage.edition}"}-${config.system.nixos.release}-${pkgs.stdenv.hostPlatform.uname.processor}";
+      default = "nixos${lib.optionalString (config.isoImage.edition != "") "-${config.isoImage.edition}"}-${config.system.nixos.release}-${pkgs.stdenv.hostPlatform.uname.processor}";
       type = lib.types.str;
       description = ''
         Specifies the label or volume ID of the generated ISO image.
@@ -535,8 +531,8 @@ in
       '';
     };
 
-    isoImage.contents = mkOption {
-      example = literalExpression ''
+    isoImage.contents = lib.mkOption {
+      example = lib.literalExpression ''
         [ { source = pkgs.memtest86 + "/memtest.bin";
             target = "boot/memtest.bin";
           }
@@ -548,15 +544,15 @@ in
       '';
     };
 
-    isoImage.storeContents = mkOption {
-      example = literalExpression "[ pkgs.stdenv ]";
+    isoImage.storeContents = lib.mkOption {
+      example = lib.literalExpression "[ pkgs.stdenv ]";
       description = ''
         This option lists additional derivations to be included in the
         Nix store in the generated ISO image.
       '';
     };
 
-    isoImage.includeSystemBuildDependencies = mkOption {
+    isoImage.includeSystemBuildDependencies = lib.mkOption {
       default = false;
       type = lib.types.bool;
       description = ''
@@ -568,7 +564,7 @@ in
       '';
     };
 
-    isoImage.makeBiosBootable = mkOption {
+    isoImage.makeBiosBootable = lib.mkOption {
       # Before this option was introduced, images were BIOS-bootable if the
       # hostPlatform was x86-based. This option is enabled by default for
       # backwards compatibility.
@@ -586,7 +582,7 @@ in
       '';
     };
 
-    isoImage.makeEfiBootable = mkOption {
+    isoImage.makeEfiBootable = lib.mkOption {
       default = false;
       type = lib.types.bool;
       description = ''
@@ -594,7 +590,7 @@ in
       '';
     };
 
-    isoImage.makeUsbBootable = mkOption {
+    isoImage.makeUsbBootable = lib.mkOption {
       default = false;
       type = lib.types.bool;
       description = ''
@@ -602,7 +598,7 @@ in
       '';
     };
 
-    isoImage.efiSplashImage = mkOption {
+    isoImage.efiSplashImage = lib.mkOption {
       default = pkgs.fetchurl {
           url = "https://raw.githubusercontent.com/NixOS/nixos-artwork/a9e05d7deb38a8e005a2b52575a3f59a63a4dba0/bootloader/efi-background.png";
           sha256 = "18lfwmp8yq923322nlb9gxrh5qikj1wsk6g5qvdh31c4h5b1538x";
@@ -612,7 +608,7 @@ in
       '';
     };
 
-    isoImage.splashImage = mkOption {
+    isoImage.splashImage = lib.mkOption {
       default = pkgs.fetchurl {
           url = "https://raw.githubusercontent.com/NixOS/nixos-artwork/a9e05d7deb38a8e005a2b52575a3f59a63a4dba0/bootloader/isolinux/bios-boot.png";
           sha256 = "1wp822zrhbg4fgfbwkr7cbkr4labx477209agzc0hr6k62fr6rxd";
@@ -622,15 +618,15 @@ in
       '';
     };
 
-    isoImage.grubTheme = mkOption {
+    isoImage.grubTheme = lib.mkOption {
       default = pkgs.nixos-grub2-theme;
-      type = types.nullOr (types.either types.path types.package);
+      type = lib.types.nullOr (lib.types.either lib.types.path lib.types.package);
       description = ''
         The grub2 theme used for UEFI boot.
       '';
     };
 
-    isoImage.syslinuxTheme = mkOption {
+    isoImage.syslinuxTheme = lib.mkOption {
       default = ''
         MENU TITLE ${config.system.nixos.distroName}
         MENU RESOLUTION 800 600
@@ -655,15 +651,15 @@ in
         MENU COLOR UNSEL        37;44      #FF000000    #00000000   none
         MENU COLOR SEL          7;37;40    #FFFFFFFF    #FF5277C3   std
       '';
-      type = types.str;
+      type = lib.types.str;
       description = ''
         The syslinux theme used for BIOS boot.
       '';
     };
 
-    isoImage.prependToMenuLabel = mkOption {
+    isoImage.prependToMenuLabel = lib.mkOption {
       default = "";
-      type = types.str;
+      type = lib.types.str;
       example = "Install ";
       description = ''
         The string to prepend before the menu label for the NixOS system.
@@ -674,9 +670,9 @@ in
       '';
     };
 
-    isoImage.appendToMenuLabel = mkOption {
+    isoImage.appendToMenuLabel = lib.mkOption {
       default = " Installer";
-      type = types.str;
+      type = lib.types.str;
       example = " Live System";
       description = ''
         The string to append after the menu label for the NixOS system.
@@ -687,9 +683,9 @@ in
       '';
     };
 
-    isoImage.forceTextMode = mkOption {
+    isoImage.forceTextMode = lib.mkOption {
       default = false;
-      type = types.bool;
+      type = lib.types.bool;
       example = true;
       description = ''
         Whether to use text mode instead of graphical grub.
@@ -706,7 +702,7 @@ in
   # store them in lib so we can mkImageMediaOverride the
   # entire file system layout in installation media (only)
   config.lib.isoFileSystems = {
-    "/" = mkImageMediaOverride
+    "/" = lib.mkImageMediaOverride
       {
         fsType = "tmpfs";
         options = [ "mode=0755" ];
@@ -715,7 +711,7 @@ in
     # Note that /dev/root is a symlink to the actual root device
     # specified on the kernel command line, created in the stage 1
     # init script.
-    "/iso" = mkImageMediaOverride
+    "/iso" = lib.mkImageMediaOverride
       { device = "/dev/root";
         neededForBoot = true;
         noCheck = true;
@@ -723,20 +719,20 @@ in
 
     # In stage 1, mount a tmpfs on top of /nix/store (the squashfs
     # image) to make this a live CD.
-    "/nix/.ro-store" = mkImageMediaOverride
+    "/nix/.ro-store" = lib.mkImageMediaOverride
       { fsType = "squashfs";
         device = "/iso/nix-store.squashfs";
-        options = [ "loop" ];
+        options = [ "loop" ] ++ lib.optional (config.boot.kernelPackages.kernel.kernelAtLeast "6.2") "threads=multi";
         neededForBoot = true;
       };
 
-    "/nix/.rw-store" = mkImageMediaOverride
+    "/nix/.rw-store" = lib.mkImageMediaOverride
       { fsType = "tmpfs";
         options = [ "mode=0755" ];
         neededForBoot = true;
       };
 
-    "/nix/store" = mkImageMediaOverride
+    "/nix/store" = lib.mkImageMediaOverride
       { fsType = "overlay";
         device = "overlay";
         options = [
@@ -760,11 +756,11 @@ in
         message = "BIOS boot is only supported on x86-based architectures.";
       }
       {
-        assertion = !(stringLength config.isoImage.volumeID > 32);
+        assertion = !(lib.stringLength config.isoImage.volumeID > 32);
         # https://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor
         # Volume Identifier can only be 32 bytes
         message = let
-          length = stringLength config.isoImage.volumeID;
+          length = lib.stringLength config.isoImage.volumeID;
           howmany = toString length;
           toomany = toString (length - 32);
         in
@@ -776,9 +772,10 @@ in
     # here and it causes a cyclic dependency.
     boot.loader.grub.enable = false;
 
-    environment.systemPackages =  [ grubPkgs.grub2 grubPkgs.grub2_efi ]
-      ++ optional (config.isoImage.makeBiosBootable) pkgs.syslinux
+    environment.systemPackages =  [ grubPkgs.grub2 ]
+      ++ lib.optional (config.isoImage.makeBiosBootable) pkgs.syslinux
     ;
+    system.extraDependencies = [ grubPkgs.grub2_efi ];
 
     # In stage 1 of the boot, mount the CD as the root FS by label so
     # that we don't need to know its device.  We pass the label of the
@@ -803,7 +800,7 @@ in
     # script and the top-level system configuration directory.
     isoImage.storeContents =
       [ config.system.build.toplevel ] ++
-      optional config.isoImage.includeSystemBuildDependencies
+      lib.optional config.isoImage.includeSystemBuildDependencies
         config.system.build.toplevel.drvPath;
 
     # Individual files to be included on the CD, outside of the Nix
@@ -819,7 +816,7 @@ in
         { source = pkgs.writeText "version" config.system.nixos.label;
           target = "/version.txt";
         }
-      ] ++ optionals (config.isoImage.makeBiosBootable) [
+      ] ++ lib.optionals (config.isoImage.makeBiosBootable) [
         { source = config.isoImage.splashImage;
           target = "/isolinux/background.png";
         }
@@ -833,43 +830,43 @@ in
         { source = "${pkgs.syslinux}/share/syslinux";
           target = "/isolinux";
         }
-      ] ++ optionals config.isoImage.makeEfiBootable [
+      ] ++ lib.optionals config.isoImage.makeEfiBootable [
         { source = efiImg;
           target = "/boot/efi.img";
         }
         { source = "${efiDir}/EFI";
           target = "/EFI";
         }
-        { source = (pkgs.writeTextDir "grub/loopback.cfg" "source /EFI/boot/grub.cfg") + "/grub";
+        { source = (pkgs.writeTextDir "grub/loopback.cfg" "source /EFI/BOOT/grub.cfg") + "/grub";
           target = "/boot/grub";
         }
         { source = config.isoImage.efiSplashImage;
-          target = "/EFI/boot/efi-background.png";
+          target = "/EFI/BOOT/efi-background.png";
         }
-      ] ++ optionals (config.boot.loader.grub.memtest86.enable && config.isoImage.makeBiosBootable) [
+      ] ++ lib.optionals (config.boot.loader.grub.memtest86.enable && config.isoImage.makeBiosBootable) [
         { source = "${pkgs.memtest86plus}/memtest.bin";
           target = "/boot/memtest.bin";
         }
-      ] ++ optionals (config.isoImage.grubTheme != null) [
+      ] ++ lib.optionals (config.isoImage.grubTheme != null) [
         { source = config.isoImage.grubTheme;
-          target = "/EFI/boot/grub-theme";
+          target = "/EFI/BOOT/grub-theme";
         }
       ];
 
     boot.loader.timeout = 10;
 
     # Create the ISO image.
-    system.build.isoImage = pkgs.callPackage ../../../lib/make-iso9660-image.nix ({
+    system.build.isoImage = pkgs.callPackage <nixpkgs/nixos/lib/make-iso9660-image.nix> ({
       inherit (config.isoImage) isoName compressImage volumeID contents;
       bootable = config.isoImage.makeBiosBootable;
       bootImage = "/isolinux/isolinux.bin";
       syslinux = if config.isoImage.makeBiosBootable then pkgs.syslinux else null;
       squashfsContents = config.isoImage.storeContents;
       squashfsCompression = config.isoImage.squashfsCompression;
-    } // optionalAttrs (config.isoImage.makeUsbBootable && config.isoImage.makeBiosBootable) {
+    } // lib.optionalAttrs (config.isoImage.makeUsbBootable && config.isoImage.makeBiosBootable) {
       usbBootable = true;
       isohybridMbrImage = "${pkgs.syslinux}/share/syslinux/isohdpfx.bin";
-    } // optionalAttrs config.isoImage.makeEfiBootable {
+    } // lib.optionalAttrs config.isoImage.makeEfiBootable {
       efiBootable = true;
       efiBootImage = "boot/efi.img";
     });
@@ -892,4 +889,5 @@ in
 
   };
 
+  system.stateVersion = lib.mkDefault lib.trivial.release;
 }
diff --git a/nixos/modules/system/boot/stage-1-init.sh b/nixos/modules/system/boot/stage-1-init.sh
index 59cf1a47f..47c5cd8bd 100644
--- a/nixos/modules/system/boot/stage-1-init.sh
+++ b/nixos/modules/system/boot/stage-1-init.sh
@@ -153,6 +153,25 @@ specialMount() {
 }
 source @earlyMountScript@
 
+info
+info "[1;32mlisting contents of /[0m"
+info
+
+ls -l --color /
+
+info
+info "[1;32mlisting contents of /dev[0m"
+info
+
+ls -l --color /dev
+
+info
+info "[1;32mdropping to bash shell[0m"
+info "[1;33mtype 'exit' to continue booting[0m"
+info
+
+bash || true
+
 # Copy initrd secrets from /.initrd-secrets to their actual destinations
 if [ -d "/.initrd-secrets" ]; then
     #
diff --git a/nixos/modules/system/boot/stage-2-init.sh b/nixos/modules/system/boot/stage-2-init.sh
index a89e3d817..8b0370f89 100755
--- a/nixos/modules/system/boot/stage-2-init.sh
+++ b/nixos/modules/system/boot/stage-2-init.sh
@@ -142,6 +142,7 @@ if [ "${IN_NIXOS_SYSTEMD_STAGE1:-}" != true ]; then
 
 
     # Start systemd in a clean environment.
-    echo "starting systemd..."
-    exec @systemdExecutable@ "$@"
+    echo "we would do 'starting systemd...' but instead we shall start bash"
+    #exec @systemdExecutable@ "$@"
+    exec bash
 fi
diff --git a/nixos/modules/system/boot/systemd/initrd.nix b/nixos/modules/system/boot/systemd/initrd.nix
index 0c24069b0..feec94b8d 100644
--- a/nixos/modules/system/boot/systemd/initrd.nix
+++ b/nixos/modules/system/boot/systemd/initrd.nix
@@ -19,13 +19,17 @@ let
   cfg = config.boot.initrd.systemd;
 
   upstreamUnits = [
-    "basic.target"
-    "ctrl-alt-del.target"
+    "poweroff.target"
+    "reboot.target"
+    "shutdown.target"
     "debug-shell.service"
     "emergency.service"
     "emergency.target"
-    "final.target"
     "halt.target"
+/*
+    "basic.target"
+    "ctrl-alt-del.target"
+    "final.target"
     "initrd-cleanup.service"
     "initrd-fs.target"
     "initrd-parse-etc.service"
@@ -40,12 +44,9 @@ let
     "local-fs.target"
     "multi-user.target"
     "paths.target"
-    "poweroff.target"
-    "reboot.target"
     "rescue.service"
     "rescue.target"
     "rpcbind.target"
-    "shutdown.target"
     "sigpwr.target"
     "slices.target"
     "sockets.target"
@@ -72,6 +73,7 @@ let
     "timers.target"
     "umount.target"
     "systemd-bsod.service"
+*/
   ] ++ cfg.additionalUpstreamUnits;
 
   upstreamWants = [
